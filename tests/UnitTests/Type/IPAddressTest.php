<?php
declare(strict_types=1);

namespace Phypes\UnitTest\Type;

use Phypes\Type\IPAddress;
use Phypes\Type\Type;
use Phypes\Validator\Validator;
use PHPUnit\Framework\TestCase;
use Mockery;

final class IPAddressTest extends TestCase
{
    public function setUp()/* The :void return type declaration that should be here would cause a BC issue */
    {
        parent::setUp(); // TODO: Change the autogenerated stub
    }

    public function testImplementsTypeInterface() : void
    {
        $this->assertInstanceOf(Type::class, $this->getValidIPAddress('127.0.0.1'));
    }

    /**
     * Check if getValue() returns correctly upon running by a mock validator
     */
    public function testGetValue() : void
    {
        $ip = $this->getValidIPAddress('127.0.0.1');
        $this->assertEquals('127.0.0.1', $ip->getValue());
    }

    /**
     * Should throw an InvalidArgumentException on failure to validate.
     */
    public function testExceptionOnFailure() : void
    {
        $failingValue = "127.0.0";

        $validator = Mockery::mock(Validator::class);
        $validator->allows()->isValid($failingValue)->andReturns(false);
        $validator->allows()->getErrorMessage()->andReturns('IP Invalid');
        $validator->allows()->getErrorCode()->andReturn(222);

        $this->expectException(\InvalidArgumentException::class);

        new IPAddress($failingValue, $validator);
    }

    /**
     * Return a valid ip address object passing validation on the mock.
     * @param string $validIPAddress
     * @return IPAddress
     * @throws \Phypes\Exception\PrematureErrorCallException
     */
    private function getValidIPAddress(string $validIPAddress) : IPAddress
    {
        $validator = Mockery::mock(Validator::class);
        $validator->allows()->isValid($validIPAddress)->andReturns(true);

        $ip = new IPAddress($validIPAddress, $validator);

        return $ip;
    }
}